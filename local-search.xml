<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《Java高并发编程指南》 学习笔记</title>
    <link href="/2022/10/12/%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/12/%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="第四章-Executor线程池框架"><a href="#第四章-Executor线程池框架" class="headerlink" title="第四章 Executor线程池框架"></a>第四章 Executor线程池框架</h1><p>在学习<code>Thread</code>时我们知道，使用线程的方法最终都是要实现一个<code>Thread</code>类，并使用其<code>start</code>方法来启动线程，这种机制没有提供对线程对象的复用，导致需要为每个<code>Runnable</code>任务都创建一个<code>Thread</code>类对象实例。</p><p>为了简化多线程使用，JDK1.5之后提供<code>Executor</code>线程池框架来管理线程，只需将<code>Runnable</code>任务交给该框架，而不需要显式地定义<code>Thread</code>对象来执行线程，而是在<code>Executor</code>内部自动调度线程执行。</p><blockquote><p>怎样自动调度？</p></blockquote><h2 id="Executor线程池框架设计概述"><a href="#Executor线程池框架设计概述" class="headerlink" title="Executor线程池框架设计概述"></a>Executor线程池框架设计概述</h2><p>在设计和实现层面，<code>Executor</code>会在内部维护一个<code>Thread</code>线程池，当有任务提交时，在内部自动调度线程池中的一个空闲线程来执行该任务。同时还会维护一个任务等待队列来存放暂时得不到执行的任务。</p><p>在实际使用中，线程是很占用系统资源的，如果对线程管理不善很容易导致系统问题。因此，在大多数并发框架中都会使用<strong>线程池</strong>来管理线程，使用线程池管理线程主要有如下好处：</p><ol><li><strong>降低资源消耗</strong>。通过复用已存在的线程和降低线程关闭的次数来尽可能降低系统性能损耗；</li><li><strong>提升系统响应速度</strong>。通过复用线程，省去创建线程的过程，因此整体上提升了系统的响应速度；</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此，需要使用线程池来管理线程。</li></ol><h2 id="Executor接口与ExecutorService接口"><a href="#Executor接口与ExecutorService接口" class="headerlink" title="Executor接口与ExecutorService接口"></a>Executor接口与ExecutorService接口</h2><p><img src="/images/Executor%E6%8E%A5%E5%8F%A3.png" alt="Executor接口"></p><h3 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Executor</span> &#123;<br>    <span class="hljs-comment">//提交一个任务到线程池异步执行</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Executor接口值包含一个execute方法，这样设计适用于表明Executor线程池框架提供的最基础的功能室实现任务的提交和任务的执行分离语义的。而在实际应用中这个功能是远远不够的，还需要考虑线程池的关闭、任务执行结果的返回等等。因此提供了下面的接口。</p><h3 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a>ExecutorService接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Executor</span>&#123;<br>    <span class="hljs-comment">//省略了一些其他方法</span><br>    <span class="hljs-comment">//关闭线程池</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//提交一个任务到线程池，异步执行</span><br>    <span class="hljs-comment">//返回一个Future对象 ，通过改对象来获取任务执行结果</span><br>    Future&lt;?&gt; submit(Runnable task);<br>    <span class="hljs-comment">//与submit方法类似，参数不同</span><br>    <span class="hljs-comment">//Callable类的call方法自身可以定义返回值，类型由T定义</span><br>    &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ThreadPoolExecutor线程池"><a href="#ThreadPoolExecutor线程池" class="headerlink" title="ThreadPoolExecutor线程池"></a>ThreadPoolExecutor线程池</h2><p>该类是对Executor线程池的具体实现，是实际应用中定义线程池最常用的一个类，也是Executor提供的一个核心类。</p><p>使用一个简单的例子来模拟线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//模拟一个打印任务的线程在线程池中执行</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadsPool</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;PrintTask is running&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">1</span>,<br>                <span class="hljs-number">1</span>,<br>                <span class="hljs-number">0L</span>,<br>                TimeUnit.MILLISECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">10</span>)<br>        );<br>        executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintTask</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="工作线程池"><a href="#工作线程池" class="headerlink" title="工作线程池"></a>工作线程池</h3><p>在<code>ThreadPoolExecutor</code>中，工作线程池是由<code>HashSet</code>实现的，但该容器不是线程安全的，因此会对该容器的操作加锁<code>ReentrantLock</code>。</p><p>而工作线程主要是通过定义一个内部类<code>Worker</code>来实现的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span><br>        <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span><br>    &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Creates with given first task and thread from ThreadFactory.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> firstTask the first task (null if none)</span><br><span class="hljs-comment">         */</span><br>        Worker(Runnable firstTask) &#123;<br>            setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>            <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>            <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/** Delegates main run loop to outer runWorker  */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            runWorker(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    <span class="hljs-comment">//省略其他方法</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>分析：该类继承自AQS，实现了<code>Runnable</code>接口</p><p>（1）继承AQS是为了基于AQS的状态变量state来定义当前现成的工作状态，并且可以以线程安全的方式来对该状态进行检查和更新，具体为根据状态变量是否等于1，来判断当前worker线程是否在处理任务。</p><p>（2）实现Runnable接口是为了将该worker类作为一个task放到Worker类内部的Thread类中去执行，在run方法中定义工作线程的逻辑。</p><h3 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h3><p>在线程池的使用层面，可以调用<code>execute</code>和<code>submit</code>方法，两种方法一种返回空，后者返回一个<code>Future</code>对象，该对象会跟踪这个任务的执行和获取执行结果。</p><p>在执行<code>execute</code>方法中，会用到<code>addWorker</code>方法，通过返回布尔值来判断当前是否可以添加任务。</p><h3 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h3><p>工作线程Worker主要是在<code>runWorker</code>方法中定义工作线程的具体工作逻辑，即执行创建该工作线程时提交的第一个任务和从任务等待队列<code>workQueue</code>获得其他等待执行的任务并执行。</p><p>该方法主要是在<code>while</code>循环中调用<code>getTask</code>方法从任务等待队列获取任务并执行。</p><p>在<code>getTask</code>方法中实现从任务等待队列<code>workQueue</code>阻塞等待获取任务 ，同时也实现了不在<code>corePoolSize</code>范围内的线程的超时清理回收机制的核心。</p><h3 id="任务执行结果"><a href="#任务执行结果" class="headerlink" title="任务执行结果"></a>任务执行结果</h3><p>如果需要获取任务的执行结果，则需要通过<code>ThreadPoolExecutor</code>的<code>submit</code>方法来提交任务。<code>submit</code>方法在该类的基类<code>AbstractExecutorService</code>中定义。获得的执行结果返回一个<code>Future</code>接口的实现类对象。具体为<code>FutureTask</code>类对象。</p><h3 id="任务拒绝策略"><a href="#任务拒绝策略" class="headerlink" title="任务拒绝策略"></a>任务拒绝策略</h3><p>当线程池无法继续创建新的工作线程，此时线程池的数量达到了<code>maximumPoolSize</code>，并且等待队列已满，对于新提交的任务需要通过<code>reject</code>方法来拒绝，策略如下：</p><ol><li>抛出Abort异常：<code>AbortPolicy</code></li><li>在主线程中直接执行该任务：<code>CallerRunsPolicy</code></li><li>直接丢弃不做任何操作：<code>DiscardPolicy</code></li><li>从任务等待队列中移除等待最久的任务：<code>DiscardOldestPolicy</code></li></ol><h3 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h3><p>分为平滑关闭and暴力关闭，对应的方法为<code>shutdown</code>和<code>shutdownNow</code>。这两个方法都是通过<code>runState</code>状态变量来做控制的。</p><ol><li>shoutdown方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//检查是否可以关闭</span><br>        checkShutdownAccess();<br>        <span class="hljs-comment">//设置runState为SHUTDOWN，不能再添加任务，但可以执行完前面的任务</span><br>        advanceRunState(SHUTDOWN);<br>        <span class="hljs-comment">//终止空闲的线程</span><br>        interruptIdleWorkers();<br>        onShutdown(); <span class="hljs-comment">// hook for ScheduledThreadPoolExecutor</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    tryTerminate();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>shutdownNow方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Runnable&gt; tasks;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//检查是否可以关闭</span><br>        checkShutdownAccess();<br>        <span class="hljs-comment">//设置runState为STOP，不能再添加任务，终止所有任务</span><br>        advanceRunState(STOP);<br>        <span class="hljs-comment">//终止所有线程</span><br>        interruptWorkers();<br>        tasks = drainQueue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    tryTerminate();<br>    <span class="hljs-comment">//该方法会返回一个workQueue中的所有线程</span><br>    <span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Future任务异步结果"><a href="#Future任务异步结果" class="headerlink" title="Future任务异步结果"></a>Future任务异步结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt;&#123;<br>    <span class="hljs-comment">//取消任务执行</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayIntertuptIfRunning)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br>    V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="任务执行结果FutureTask"><a href="#任务执行结果FutureTask" class="headerlink" title="任务执行结果FutureTask"></a>任务执行结果FutureTask</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt;&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RunnableFuture</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Runnable</span>,Future&lt;V&gt;&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 在具体实现层面，线程池的工作线程和主线程之间通过状态变量<code>state</code>来通知对方当前任务的执行状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt;&#123;<br>    <span class="hljs-comment">//状态转换过程</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">* NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="hljs-comment">* NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="hljs-comment">* NEW -&gt; CANCELLED</span><br><span class="hljs-comment">* NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="任务的提交和返回执行结果"><a href="#任务的提交和返回执行结果" class="headerlink" title="任务的提交和返回执行结果"></a>任务的提交和返回执行结果</h3><p>在应用主线程中调用<code>submit</code>方法提交任务到<code>Executor</code>线程池框架内部的线程池，并调用异步结果封装类<code>FutureTask</code>的<code>get</code>方法阻塞获取任务执行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-comment">//当线程未开始或在执行中时调用awaitDone方法</span><br>    <span class="hljs-keyword">if</span> (s &lt;= COMPLETING)<br>        <span class="hljs-comment">//线程休眠 等待执行结果</span><br>        s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>    <span class="hljs-keyword">return</span> report(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>FutureTask</code>内部维护了一个单向链表<code>waiters</code>，用于存放当前等待该任务执行结果的线程，在执行完成时遍历该链表，唤醒每个等待线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> WaitNode waiters;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNode</span>&#123;<br>    <span class="hljs-keyword">volatile</span> Thread thread;<br>    <span class="hljs-keyword">volatile</span> WaitNode next;<br>    WaitNode()&#123;<br>        thread = Thread.currentThread();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ScheduledExecutorService任务周期性执行"><a href="#ScheduledExecutorService任务周期性执行" class="headerlink" title="ScheduledExecutorService任务周期性执行"></a>ScheduledExecutorService任务周期性执行</h2><p>JDK1.5之前对于周期性任务使用<code>Timer</code>类来执行，该类包含一下缺陷：</p><ol><li>该类中只有一个线程，所有任务都在这个线程中执行，一个任务时间长会导致另一个任务长期等待。</li><li>执行过程中，一个任务的异常会导致线程退出，所有任务都会停止。</li><li>该类依赖系统时间执行，系统时间变化则线程也会发生变化。</li></ol><p>针对该问题创建<code>ScheduledExecutorService</code>接口的实现类来解决问题。</p><h2 id="Executors线程池创建工具"><a href="#Executors线程池创建工具" class="headerlink" title="Executors线程池创建工具"></a>Executors线程池创建工具</h2><p>为简化<code>ThreadPoolExecutor</code>的使用，提供额了<code>Executors</code>工具类，该类能创建特定版本的线程池对象，即在该类内部提供了创建线程池对象所需的默认参数，通过方法名来表明特定的创建，从而简化了线程池的创建。</p><p><code>Executors</code>工具类主要关注线程池的<strong>线程数量</strong>和<strong>任务等待队列</strong>的定义，具体分为线程数量的固定时，等待队列无界和线程数量无界；其中等待队列无界应用于对实时性要求不高的场景，此时不会因为任务太多而创建大量的线程；线程数量无界应用于实时性要求高的场景，对每一个任务都会调度一个空闲线程或创建一个新线程来执行。</p><h2 id="ForkJoin任务分解与并行执行框架"><a href="#ForkJoin任务分解与并行执行框架" class="headerlink" title="ForkJoin任务分解与并行执行框架"></a>ForkJoin任务分解与并行执行框架</h2><p>该框架是JDK1.7推出的，主要目的是实现任务的自动化递归拆分，支持将一个大任务拆分为多个小任务，然后交给线程池的多个线程进行处理。</p><p>从任务的角度来看，大任务分为多个小任务，由于任务数量常常多于线程数量，因此拆分的小任务会被分到多个工作队列中等待线程处理。</p><p>从线程池的角度看，<code>ForkJoinPool</code>线程池内的线程会关联这些工作队列，同时线程之间支持任务窃取，即空闲线程可以窃取其他线程工作队列的任务来处理，从而提高线程池效率。在窃取方面，为了减少线程之间的竞争，工作队列采用双端队列的方式实现，即工作队列的拥有者从头部获取任务，窃取任务的线程从尾部获取任务。</p><h1 id="第八章-分布式系统设计理论"><a href="#第八章-分布式系统设计理论" class="headerlink" title="第八章 分布式系统设计理论"></a>第八章 分布式系统设计理论</h1><h2 id="系统架构演进"><a href="#系统架构演进" class="headerlink" title="系统架构演进"></a>系统架构演进</h2><p>应用系统架构的演进都是随着业务的发展而变化的，业务开发初期系统的用户量和访问量都比较小，因此可以采用单体应用架构。而当用户量和访问量增大时，就需要采用分布式架构和集群部署的方式。</p><h3 id="单体应用架构"><a href="#单体应用架构" class="headerlink" title="单体应用架构"></a>单体应用架构</h3><p>该模式下耦合性较高，修改bug和部署系统时都需要将整个系统都重新启动和部署。</p><h3 id="分布式应用架构"><a href="#分布式应用架构" class="headerlink" title="分布式应用架构"></a>分布式应用架构</h3><p><strong>优点</strong></p><p>分布式应用架构是指将一个系统的多个模块拆分为多个子服务，每个子服务都使用一个独立进程来部署，并且一般部署在不同的机器节点。该方案具有较好的拓展性，以及更高的并发性和安全性。</p><p><strong>缺点</strong></p><p>分布式系统每个子服务的通信比较依赖网络传输。</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p><strong>分布式与集群的区别</strong></p><p>分布式通产是指如何将一个系统拆分为多个子服务或者多个子系统，各个子服务独立部署在一个进程里，如果这些子服务都只部署一个实例，则这个系统是分布式系统。</p><p>集群式是指同一个服务在在不同机器节点上部署多次，这些机器节点提供相同的服务，并且通过负载均衡机制将对该服务的请求分散到各个节点。即集群是通过实现系统的横向拓展来应对高并发请求和提高系统的吞吐量的。</p><p>单体应用架构和分布式应用架构都可以通过集群的方式来部署。</p><h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><p>在分布式系统中由于需要将一个系统的多个功能模块拆分为多个子服务，每个子服务以独立进程部署，子服务之间通过网络进行通信，由于网络传输不稳定和数据传输延迟的问题，子服务之间常会出现无法通信或通信延迟。</p><p>其次在<strong>单体应用架构</strong>中，一个请求可能会调用多个功能模块来处理，由于是发生在同一个进程内，因此可以基于数据库的事务机制来保证数据的强一致性。</p><p>在<strong>分布式系统设计</strong>中，针对数据不一致的情况，要么是所有子服务都执行成功才提交此数据的修改，在此期间服务将会被占用，不能响应其他请求；要么各自执行自己的服务，时候再检查是否都成功，如果存在某些失败，那么采用一些补偿机制来保证数据一致性。</p><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>CAP理论时指出在分布式系统设计中存在<strong>数据强一致性</strong>和<strong>服务高可用</strong>的两个指标，以及一个不可避免的网络分区缺陷，网络分区对应的网络分区容忍。</p><p>首先数据一致性和服务高可用在分布式系统中是不能同时存在的。 </p><p>在传统CAP理论中，数据强一致性通常是指在分布式存储系统中，数据存储直接点与多个备份节点数据在任何时候都需要保持一致。任何时候，客户端需要请求某项数据时，可以访问任意一个节点，即主节点或者备份节点都会返回相同的数据。</p><p>服务高可用是指客户端在任何时候需要获取某项数据时，都可以随时访问对应的数据存储节点，并且数据存储节点都可以成功返回该数据。</p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p>BASE理论可以看做是CAP理论的延伸，CAP理论只是说明了两者不能同时存在，并没有提出解决方法，BASE理论则提出了方案。该理论通过一种折中的方式，通过牺牲数据强一致性，来保证服务可用性，即允许数据在一段时间内是不一致的，在一段时间以后会恢复一致。</p><p><strong>基于可用BA：</strong>不是完全不可用，而是服务质量会有所损失。</p><p><strong>软状态S：</strong>允许在某一个有限的时间内，数据存在中间状态。</p><p><strong>最终一致性E</strong></p><p>在进行分布式系统设计时，可基于BASE理论来分析当前的分布式系统是否能够满足BASE理论的三个条件：基本可用，软状态和最终一致性。如果满足，说明该系统在出现网络分区时可以保持服务的可用性。</p><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p>现代互联网中，尤其是大型网站，访问量和客户量都十分庞大，因此大多都会采用分布式应用架构和集群部署方案。具体为通过分布式架构拆分出多个子服务来提高系统的横向拓展性，再通过集群部署提高每个服务的吞吐量和可用性。</p><p>在服务器的集群部署中，由于存在多个节点可以响应一个服务的请求，因此会存在一种负载均衡机制来对该服务的请求分散到这些节点中， 从而实现集群的横向拓展性和提高服务的整体吞吐量。</p><p>除了设计分布式应用架构和集群部署之外，在应用层面也要有所优化，首先，在高并发访问中最有可能出现性能瓶颈的就是数据库，因此通过增加分布式缓存减少对数据库的访问来解决数据库的性能瓶颈问题。其次通过请求的异步处理来加快请求的响应速度，提高系统的吞吐量。具体实现可以通过消息队列缓冲请求实现。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《Concurrent  Programming in Java》读书笔记</title>
    <link href="/2022/10/10/%E3%80%8AConcurrent%20%20Programming%20in%20Java%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/10/%E3%80%8AConcurrent%20%20Programming%20in%20Java%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象的并发编程"><a href="#面向对象的并发编程" class="headerlink" title="面向对象的并发编程"></a>面向对象的并发编程</h1><p>介绍Java并发的三种概念：</p><p><strong>独占（Exclusion）：</strong>可以通过组织多个并发行为间的有害干扰来维护对象状态的一致性。通常使用<strong>同步（<code>synchronized</code>）</strong>的方法。</p><p><strong>状态依赖（State Dependency）：</strong>是否可以触发、组织、延迟或是恢复某些行为是由一些对象是否处在这些行为可鞥成功或是已成功的状态上决定的。通常状态依赖关系使用<strong>监视器</strong>（<code>monitor</code>）的方法实现，such as <code>wait()</code>,<code>notify()</code>。</p><p>**创建线程（Creating Threads）:**使用线程对象来创建和管理并发操作。</p><p>使用一些简单的规则来定义同步的问题：</p><p>· 只在更新对象的成员变量时加锁</p><p>· 只在访问有可能更新的成员变量时加锁</p><p>· 不要在调用其他对象的方法时加锁</p><blockquote><p>前两个是在读写变量时加锁，第三个是可能会出现死锁（双方都同时加锁）</p></blockquote><h2 id="线程机制"><a href="#线程机制" class="headerlink" title="线程机制"></a>线程机制</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>线程的构造方法中包含三个参数：</p><p>—— <code>Runnable</code>对象：<code>Thread.start</code>方法会调用该对象的<code>run</code>方法，若不传递该参数，会运行<code>Thread.run</code></p><p>——<code> String</code>对象：作为<code>Thread</code>对象的名称</p><p>—— <code>ThreadGroup</code>对象：放置新的<code>Thread</code>，如果没有显式指定，那么默认将⽗线程 （当前执⾏<code>new Thread</code>的线程）线程组设置为⾃⼰的线程组。</p><blockquote><p><code>ThreadGroup</code>类的方法都是以线程组操作为目的的，包括设置线程组中线程的最大优先级方法、将线程组中所有线程挂起或恢复到可运行状态的方法、终止线程组中所有线程的方法等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> resume（）； <span class="hljs-comment">//使被挂起的当前组内的线程恢复到可运行状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDaemon</span> <span class="hljs-params">(<span class="hljs-type">boolean</span> daemon)</span>; <span class="hljs-comment">//指定一个线程为当前线程组的监护线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> setMaxPriority（<span class="hljs-type">int</span> pri）； <span class="hljs-comment">//设置当前线程组允许的最大优先级</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> stop（）；<span class="hljs-comment">//终止当前线程组中所有线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> suspend（）; <span class="hljs-comment">//挂起当前线程组中所有线程</span><br><span class="hljs-keyword">public</span> String toStrinng（）; <span class="hljs-comment">//将当前线程组转换为String类的对象 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t,Throwable e)</span>; <span class="hljs-comment">//当一个线程组中的线程由于未被捕捉的异常而导致终止时，该方法会被调用，会打印出当前的堆栈跟踪信息（stack trace）</span><br></code></pre></td></tr></table></figure></blockquote><p>通常的策略是把<code>Runnable</code>接口当做一个单独的类来实现，并把它作为参数传递给一个<code>Thread</code>的构造函数。</p><p>也可以继承<code>Thread</code>的子类来实现线程。</p><h3 id="控制方法"><a href="#控制方法" class="headerlink" title="控制方法"></a>控制方法</h3><p> 每一个线程都对应一个中断（interruption）状态，用布尔变量表示，通过调用<code>Thread.interrupt()</code>方法使该变量设置为<code>true</code>。但在其处理<code>Thread.wait() </code> <code>Thread.sleep()</code> <code>Thread.join()</code> 方法时调用该方法会抛出异常，线程将被设置为<code>false</code>。</p><p><code>Thread.yield()</code>是Thread的一个静态方法，用来告知JVM若系统中有处在未运行状态的活动线程，那么调度程序可以从这些线程中选择一个运行而放弃当前的线程，JVM可以使用自己的方式理解这个建议。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>常见并发编程的应用：</p><p><strong>Web服务（Web Service）：</strong>多数基于套接字的Web服务都是多线程的，支持多个并发的连接可以保证当有新的连接到来时可以立即被处理，不需要等待其他连接结束，降低了延迟。</p><p><strong>数值计算</strong></p><p><strong>I&#x2F;O处理</strong></p><p><strong>模拟程序：</strong>并发程序可以用来模拟物理世界中有着独立自主行为的对象。</p><p><strong>GUI程序</strong></p><p><strong>嵌入式系统</strong></p><h3 id="并发执行构件"><a href="#并发执行构件" class="headerlink" title="并发执行构件"></a>并发执行构件</h3><p>实现并发执行有多种方式，线程只是其中一种。</p><h4 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h4><p>如果有一群可用的计算机系统，可以将每一个逻辑运算单元映射到一个计算机上构建一个计算机集群，该方式可以带来无限的<strong>自治性</strong>和<strong>独立性</strong>，但每个计算机之间的开销会非常昂贵，并且不能共享本地资源。</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p><strong>共享：</strong>Java实现了线程可以共享内存，文件等类似的资源。</p><p><strong>调度：</strong></p><p><strong>通信：</strong>线程可以通过基于内存的同步机制来进行通信。</p><h4 id="任务和轻量级执行框架"><a href="#任务和轻量级执行框架" class="headerlink" title="任务和轻量级执行框架"></a>任务和轻量级执行框架</h4><p>当线程的创建和管理的开销已经成为影响程序性能的因素之一时，通过创建自己的轻量级执行框架，并加以限制（如禁止某种方式的阻塞），提供更少的调度保证，或是更少的同步和通信手段，可以进一步减少自治性来提高性能。  </p><h2 id="设计因素"><a href="#设计因素" class="headerlink" title="设计因素"></a>设计因素</h2><p>从两个互</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读后感</tag>
      
      <tag>Java学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Thinking in Java》读书笔记</title>
    <link href="/2022/10/08/%E3%80%8AThinking%20in%20Java%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/08/%E3%80%8AThinking%20in%20Java%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="《Thinking-in-Java》读书笔记"><a href="#《Thinking-in-Java》读书笔记" class="headerlink" title="《Thinking in Java》读书笔记"></a>《Thinking in Java》读书笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>程序设计其实是对复杂性的管理：待解决问题的复杂性，以及用来了解决该问题的工具的复杂性。</p><p>sun对Java的设计目标：“我们关心的是，减少开发健壮代码所需的时间以及困难。”</p><p>Java解决了一些相当大的复杂性问题：跨平台编程、动态代码修改、安全等问题。</p></blockquote><h2 id="第一章-对象导论"><a href="#第一章-对象导论" class="headerlink" title="第一章 对象导论"></a>第一章 对象导论</h2><p>Alan Kay总结的smalltalk（第一个OOP语言，Java基于的语言之一）五大特性：</p><ol><li>万物皆为对象</li><li>程序是对象的集合，他们通过发送消息来告知彼此所要做的。</li><li>每个对象都有自己的由其他对象所构成的存储。</li><li>每个对象都拥有其类型。<em>每个对象都是某个类的一个实例。</em></li><li>某一特定类型的所有对象都可以接受同样的消息。</li></ol><p>每个对象在内存中都有一个唯一地址。</p><h3 id="每个对象都有一个接口"><a href="#每个对象都有一个接口" class="headerlink" title="每个对象都有一个接口"></a>每个对象都有一个接口</h3><p>程序员可以通过定义类来适应问题，而不用再被迫使用现有用来表示机器中存储单元的数据类型。</p><p>![截屏2022-09-15 23.15.42](&#x2F;Users&#x2F;yangboqing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-15 23.15.42.png)</p><h3 id="每个对象都提供服务"><a href="#每个对象都提供服务" class="headerlink" title="每个对象都提供服务"></a>每个对象都提供服务</h3><p>当正在试图开发或理解一个程序设计时，最好的方法之一就是将对象想象为“服务提供者”。</p><h3 id="被隐藏的具体体现"><a href="#被隐藏的具体体现" class="headerlink" title="被隐藏的具体体现"></a>被隐藏的具体体现</h3><p>程序开发人员可以分为：类创建者（<em>那些创建新数据类型的程序员</em>），客户端程序员（<em>使用数据类型的程序员</em>）。</p><p>类创建者可以只向客户端程序员提供必须的部分，隐藏一些不对外开放的，脆弱的接口或数据，避免使用者使用时出现bug。</p><blockquote><p>关键字：</p><p>public </p><p>private</p><p>protected</p></blockquote><h3 id="复用具体体现"><a href="#复用具体体现" class="headerlink" title="复用具体体现"></a>复用具体体现</h3><p>最简单的复用就是创建一个类的实例</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>两种方法可以使父类和子类产生差异：</p><ol><li>直接在子类中添加新方法；</li><li>改变父类中现有的方法（覆盖 overriding）。</li></ol><h3 id="伴随多态的可互换对"><a href="#伴随多态的可互换对" class="headerlink" title="伴随多态的可互换对"></a>伴随多态的可互换对</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">do</span><span class="hljs-params">(Shape shape)</span>&#123;<br>shape.draw();<br>&#125;<br><br><span class="hljs-type">Circle</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>();<br><span class="hljs-keyword">do</span>(circle)<br></code></pre></td></tr></table></figure><p>Circle类继承了Shape父类，其中覆写了Shape中的draw()方法。</p><p>在Java中，一个类只能继承一个父类。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>问题：如果在不知道要创建多少个对象时，就不知道如何存储这些对象。</p><p>为了解决这一问题，就有了<strong>容器</strong>，也称为<strong>集合</strong>。</p><p><code> List</code></p><p> <code>Map</code>  </p><p><code>Set</code></p><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p><code>ArrayList&lt;Shape&gt; list = new ArrayList&lt;&gt;();</code></p><h3 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h3><p>Java完全采用了动态内存分配方式，每次想要创建对象时需要使用new来构建该对象的动态实例。</p><p>Java提供了“垃圾回收器”，会自动释放对象占用的内存。</p><p>两种特性：所有对象都继承自Object类，且只能以一种方式创建对象（堆创建）。</p><h2 id="第二章-一切都是对象"><a href="#第二章-一切都是对象" class="headerlink" title="第二章 一切都是对象"></a>第二章 一切都是对象</h2><h3 id="用引用操作对象"><a href="#用引用操作对象" class="headerlink" title="用引用操作对象"></a>用引用操作对象</h3><p>在Java中一切都是对象，但操作对象其实是操作对象的一个“引用”。</p><p><code> String s</code></p><p>上面的s就是一个引用，这个引用可以不用与一个对象关联，可以在之后给这个引用分配一个对象。</p><h3 id="对象存储的位置"><a href="#对象存储的位置" class="headerlink" title="对象存储的位置"></a>对象存储的位置</h3><ol><li>寄存器。位于处理器中</li><li>堆栈。位于通用RAM（随机访问存储器）中，堆栈指针向下移动创建新空间，向上移动释放内存。用于存放Java引用。</li><li>堆。一种通用内存池（RAM中），用于存放Java对象。当需要一个对象时，只需要 new 一个对象，当执行该代码时，会自动在堆里进行存储分配。费时。</li><li>常量存储。</li><li>非RAM存储。<em>流对象</em>、<em>持久化对象</em></li></ol><h4 id="特例：基本类型"><a href="#特例：基本类型" class="headerlink" title="特例：基本类型"></a>特例：基本类型</h4><p>由于new的对象存储在堆里，所以当new一个小而简单的对象时，在堆中建立该对象费时就很没有效率。对于这些变量Java不用new创建，而是使用一个非“引用”的”自动“变量，这个变量直接存储值，存储在<em><strong>堆栈</strong></em>中。</p><table><thead><tr><th>基本类型</th><th>大小</th></tr></thead><tbody><tr><td>boolean</td><td>-</td></tr><tr><td>char</td><td>16-bit</td></tr><tr><td>byte</td><td>8 bits</td></tr><tr><td>short</td><td>16bits</td></tr><tr><td>int</td><td>32bits</td></tr><tr><td>long</td><td>64bits</td></tr><tr><td>float</td><td>32bits</td></tr><tr><td>double</td><td>64bits</td></tr><tr><td>void</td><td>-</td></tr></tbody></table><h3 id="永远不要销毁对象"><a href="#永远不要销毁对象" class="headerlink" title="永远不要销毁对象"></a>永远不要销毁对象</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>基本数据类型的生命周期在花括号外不能被引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>  &#123;<br>    <span class="hljs-comment">//该作用域中包含b和a</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-comment">//该作用域中值包含a</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Java对象不具备基本类型的生命周期，因此可以存活于作用域外。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>  &#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>);  <br>  &#125;<br>  <span class="hljs-comment">//s不能被访问</span><br>&#125;<br></code></pre></td></tr></table></figure><p>尽管s在作用域外不能被访问，但是s指向的String对象仍然占据内存空间。后续会看到怎样传递和复制对象引用。</p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">StaticClass</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticClass</span>();<br>    <span class="hljs-type">StaticClass</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticClass</span>();<br>    <span class="hljs-comment">//可以通过对象直接定位该值</span><br>    s1.a = <span class="hljs-number">2</span>;  <span class="hljs-comment">//s2.a的值也变为2</span><br>    <span class="hljs-comment">//也可以通过其类名直接调用</span><br>    StaticClass.a++; <span class="hljs-comment">//a的值也变为3</span><br>    StaticClass.increment();<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticClass</span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//两种方法均会使共享变量加1</span><br>    StaticClass.a++;<br>    a++;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>static关键字声明的变量指向同一内存空间，不管创建了多少对象实例，都具有相同的值。</p><p>static声明的方法<code>increment()</code>也可以通过<code>StaticClass.increment();</code>直接调用。</p><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class Test&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> main方法中的<code>args[]</code>用来存储命令行参数</p><h2 id="第三章-操作符"><a href="#第三章-操作符" class="headerlink" title="第三章 操作符"></a>第三章 操作符</h2><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">Human</span> <span class="hljs-variable">h1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Human</span>(<span class="hljs-string">&quot;dave&quot;</span>);<br>    <span class="hljs-type">Human</span> <span class="hljs-variable">h2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Human</span>(<span class="hljs-string">&quot;jack&quot;</span>);<br>    h2.name = <span class="hljs-string">&quot;tom&quot;</span>;<br>    h1 = h2; <span class="hljs-comment">//此时h1.name变为了tom</span><br>    h1.name = <span class="hljs-string">&quot;sam&quot;</span>; <span class="hljs-comment">//此时h2.name变为了sam</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>&#123;<br>  String name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Huamn</span><span class="hljs-params">(String name)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java中对象引用的赋值是对地址的赋值：<code>h1=h2</code>，此时两个引用指向同一地址，改变任何一个都会改变另一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(Human h)</span>&#123;<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> h;<br>        a.t++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">Human</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Human</span>();<br>    h.f(h);<span class="hljs-comment">//此时h中的a值变为2</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java中方法的参数是对象时，相当于引入了它的地址，因此在方法<code>f()</code>中给新的<code>Human</code>对象赋值h后，改变a的值相应的会改变方法外h的值。</p><h2 id="第四章-控制执行流程"><a href="#第四章-控制执行流程" class="headerlink" title="第四章 控制执行流程"></a>第四章 控制执行流程</h2><p>——————</p><h2 id="第五章-初始化和清理"><a href="#第五章-初始化和清理" class="headerlink" title="第五章 初始化和清理"></a>第五章 初始化和清理</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>Java采用的C++的方法：方法名与类名相同。</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>Java允许在类中定义一个名为<code> finalize()</code>的方法，它的工作原理假定：一旦垃圾回收器准备好释放对象占用的内存空间，将首先调用该方法，并在下一次垃圾回收动作发生时才会真正回收对象占用的内存。</p><p>C++中存在<code>析构函数</code> ，当C++销毁对象时一定会用到该函数，并且在C++中独享一定会被销毁。但在Java中并非如此：</p><ol><li>对象可能不会被垃圾回收</li><li>垃圾回收并不等于“析构”。</li><li>垃圾回收只与内存有关。（使用垃圾回收的唯一原因是为了回收程序不再使用的内存）</li></ol><p>如果JVM没有面临内存耗尽的情形，它是不回浪费时间去进行垃圾回收的。</p><p>Java的垃圾回收器工作时，将一面回收空间，一面使堆中的对象紧凑排列，这样“堆指针”很容易移动到靠近堆栈的开始处。</p><h4 id="“停止-复制”模式"><a href="#“停止-复制”模式" class="headerlink" title="“停止-复制”模式"></a>“停止-复制”模式</h4><p>该模式下，在垃圾回收动作发生时，会暂停程序运行，并将所有&#x3D;&#x3D;存活&#x3D;&#x3D;的对象从一个堆栈中的数据复制到一个新的堆栈中，被复制到新堆栈中的对象都是连续排列的。该模式下效率极低，某些Java虚拟机的处理方式是按需从堆中分配几块大的块，从块之间发生复制动作。</p><h4 id="“标记-清扫”模式"><a href="#“标记-清扫”模式" class="headerlink" title="“标记-清扫”模式"></a>“标记-清扫”模式</h4><p>如果没有新垃圾的产生，就会转换到另一种工作模式，该方式速度相当慢，适合处理产生少量垃圾时的情况。该方法同样是从堆栈和静态存储区出发， 遍历所有引用，进而找出所有存活的对象。每当找到一个存活对象就会给对象设一个标记，当全部标记完后开始清理。这样得到的堆空间是不连续的。该动作同样需要暂停程序进行。</p><h2 id="第六章-访问权限控制"><a href="#第六章-访问权限控制" class="headerlink" title="第六章 访问权限控制"></a>第六章 访问权限控制</h2><h3 id="定制工具库"><a href="#定制工具库" class="headerlink" title="定制工具库"></a>定制工具库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> demo.util<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Print</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(Obejct obj)</span>&#123;<br>        System.out.print(obj);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">println</span><span class="hljs-params">(Obejct obj)</span>&#123;<br>        System.out.println(obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在定义一个自己工具类中的一个静态方法之后，就可以静态调用使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> demo.util.Print;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        print(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        println(<span class="hljs-string">&quot;bbb&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第七章-复用类"><a href="#第七章-复用类" class="headerlink" title="第七章 复用类"></a>第七章 复用类</h2><blockquote><p>每一个非基本类的对象都有一个<code>toString()</code>方法。当编译器需要一个String时，该对象无法提供一个String时就会调用该方法。</p></blockquote><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>一个既是static又是final的域只占一段不能改变的存储空间。</p><p>当对象引用而不是基本类型使用final时，final使引用恒定不变，当它指向一个对象时，就无法改变它指向另一个对象，但可以修改一个对象的内容。</p><p>Java允许生成空白final数据，但编译器会确保在该数据使用前必须被初始化。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>使用final方法的原因：把方法锁定，防止继承类重构该方法。</p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>当final一个类时，表示你不打算继承该类，也不允许其他人这样做。</p><h2 id="第八章-多态"><a href="#第八章-多态" class="headerlink" title="第八章 多态"></a>第八章 多态</h2><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p>对象既可以作为<strong>本身</strong>的类型使用，也可以作为他的<strong>基类型</strong>使用，这种把对某个对象的引用视为对其基类型的引用的做法被称作<strong>向上转型</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Job</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jobName</span><span class="hljs-params">(String name)</span>&#123;<br>        print(<span class="hljs-string">&quot;JobName:&quot;</span>+name);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Police</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Job</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jobName</span><span class="hljs-params">(String name)</span>&#123;<br>        print(<span class="hljs-string">&quot;PoliceJobName:+&quot;</span>+name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printName</span><span class="hljs-params">(Job j)</span>&#123;<br>        j.jobName(j);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Police</span> <span class="hljs-variable">pol</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Police</span>();<br>        printName(pol);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态绑定vs动态绑定"><a href="#静态绑定vs动态绑定" class="headerlink" title="静态绑定vs动态绑定"></a>静态绑定vs动态绑定</h3><p>绑定指的是一个方法的调用与方法所在的类（方法主体）关联起来。</p><p>静态绑定（前期绑定）：程序在执行前方法已经被绑定（即在编译过程中就知道这个方法到底是哪个类中的方法）。Java方法中只有final、static、private和构造方法（<strong>本质是一个静态方法</strong>）是前期绑定的。</p><p>动态绑定（后期绑定）：在运行时根据对象的类型进行绑定，可以在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读后感</tag>
      
      <tag>Java学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
